LOOT Metadata File Format
==========================

The LOOT metadata file format is a YAML file which contains a specific set of
data in a specific structure. It is used by the masterlist, the userlist and the
lastrun file.

General properties are:
  1. Keys and keywords (such as message types, conditional types) are lowercase.
  2. Whitespace is important: a two-space indentation should be used between
     each level.
  3. All YAML properties.

In YAML, the message object is:
---
!message:
    condition: OPTIONAL !condition
    type: REQUIRED !!string
    content: REQUIRED !!string
    lang: OPTIONAL !!string
...
Allowed values for the 'type' node are "say", "warn" or "error". The semantics
of the types are:
        say             Generic message type, carries no semantics.
        warn    A warning message, detailing a non-critical installation issue.
        error   An error message, detailing a critical installation issue.

The 'content' node string will treat all file:// , http:// and https:// links as
hyperlinks. A link can be given a label by enclosing it and the label in double
quotes, eg. "http://www.example.com example link".
The 'lang' node takes an ISO 639-3 language string, of which there are a set defined for the languages LOOT supports (as yet, just 'eng').


The file object:
---
!file:
        condition: OPTIONAL !condition
        name: REQUIRED !!string
        ver: OPTIONAL !!int or !!string
        display: OPTIONAL !!string
        operator: OPTIONAL !!string
...
CRCs are given as hex integers prefixed by 0x. The 'display' node allows the name
of the parent mod or program to be used instead of the filename in messages.
'operator' is the comparison operator used for the version check (if performed).
'>=' is the default used if not specified, other possibilities include =, <, etc.

The tag object:
---
!tag:
    condition: OPTIONAL !condition
    name: !!string
...
This object can be used to represent a conditional tag. 'name' is the tag name,
eg. Graphics.


The condition string:
---
!condition: REQUIRED !!string
...
Syntax of the string is the same as is currently for BOSS, except the following:
  1. The VAR, REGEX and LANG condition types have been removed.
  2. The FILE condition type now evaluates regex path strings.
  3. The '&&' and '||' operators have been replaced with 'and' and 'or' respectively.
  4. Condition keywords, types and operators are all lowercase.
  5. Brackets may be used to logically group conditions in compound conditions.
  6. Evaluation of compound conditionals is done according to standard operator
     precedence rules.


The plugin object:
---
!plugin:
        name: REQUIRED !!string
        priority: OPTIONAL !undecided
        enabled: OPTIONAL !bool
        after: OPTIONAL [!file]
        req: OPTIONAL [!file]
        inc: OPTIONAL [!file]
        msg: OPTIONAL [!message]
        tag: OPTIONAL [!!string or !tag]
...
The 'name' node can be either an exact filename or a regular expression. The
difference will be determined by looking for the "\.esp" or "\.esm" substrings,
which are only valid for a regular expression.
The type of the 'priority' node has not been decided yet, as it's not yet clear
how much fidelity is required for it.
If any of the 'req' node objects are not present, an error message will be
displayed. If any of the 'incs' node objects are present, an error message will
be displayed.
The 'req' node objects must be listed in load order. The 'req' and 'inc'
nodes may contain a mix of plugin and non-plugin objects.
If the 'enabled' node is not specified, its value is assumed true. It is
provided for use in the userlist.
The 'after' node is a list of plugins that the object plugin must load after, intended for use specifying implicit dependencies. It may also be used in the userlist to specify custom positions.
The 'tag' node holds an array of Bash Tags to be suggested. Tags that are prepended with a '-' (eg. '-Graphics') are suggested for removal, otherwise tags are suggested for addition.


Simple Example
--------------

---
- name: MyMod.esp
  req:
    - name: AnotherMod.esp
    - name: AnotherModPatch.esp
  msg:
    - type: say
      content: "This is my mod."
    - type: say
      content: "This is a second message."
...


Complex Example
---------------

---
# Note that classes are not specified, YAML will treat them as assoc. arrays,
# LOOT will assume they are file objects.
filevars:
  - &GAME name: "TESV.exe"
  - &MASTER {name: "Oblivion.esm", ver: "1.2.416"}
  - &SE name: "obse_loader.exe"
  - &TEST {name: "Test.esp", ver: 0x0537AB3C}
  - &SE20 <<: [*SE, ver: "0.0.20.1"]

msgvars:
  - &OBSOLETE {type: SAY, content: "Obsolete. Remove and upgrade to the latest version."}

globals:
  - {type: SAY, content: "You're using LOOT!"}

- name: Oblivion.esm
  msg:
    - {condition: exp: "IF FILE("TESV.exe")", type: WARN, content: "False alarm."}
    - <<: {*OBSOLETE, content: Quotes aren't necessary, unless the message contains special chars. }
...


LOOT Plugin Data Cache Format
=============================

The formatting of this cache doesn't need to be human-readable, but must
contain the following information for each plugin:

  * Filename (for roughly identifying the file)
  * CRC (for precisely identifying the exact file)
  * Masters in the order they appear in the plugin's master list.
  * FormIDs of the records it edits (not added records).

Rather than have a single cache file, it is more efficient past the short
term to use a different file for each plugin filename's data, even after
taking into account the additional networking cost of using many small
files. See the section after the divider below for the analysis.

The cache file extension will be ".dc", an acronym for "data cache". Each
cache file will share the filename of the plugin that it holds the data of,
including the plugin's file extension, eg. "Unofficial Oblivion Patch.esp.dc".

In each cache file, the data will be divided into entries for each of the
different versions of that file, which are handled using their CRCs. These
entries make up the bulk of the file, and are followed by an index of CRCs
and offsets to their corresponding data at the end of the file.

    Name            Type                        Details
    ---------------------------------------------------------------------------
    Version         uint8_t                     Version number for the file's
                                                format (in case it changes).
    Name Length     uint8_t                     The plugin filename's length.
    Filename        char[Name Length]           Not null terminated.
    Data Entries    data entry[Entry Count]
    Index           index entry[Entry Count]
    Entry Count     uint32_t

Each data entry has the following structure:

    Name            Type                    Details
    ---------------------------------------------------------------------------
    Size            uint32_t                Total size of data entry, not
                                            including this value.
    Masters Length  uint16_t                Includes null characters.
    Masters         char[Masters Length]    Null-terminated filenames in order
                                            of how they appeared in the plugin.
    FormIDs         uint32_t[len]           len = (Size - Masters Length) / 4

Each index entry has the following structure:

    Name            Type                    Details
    ---------------------------------------------------------------------------
    File CRC        uint32_t
    Data offset     uint32_t                From beginning of file.

All numbers are encoded low to high byte. All strings are encoded in UTF-8.

The reason for this structure is to optimise the processes that will be
performed upon cache files: searching, reading data and appending new data.
The index allows quick searching of the file as it is composed of a given
number of entries with defined size. It is located at the end of the file
rather than the more usual beginning so that appending new data does not
need to rewrite the whole file to also update the index: only the index and
filename data will ever be rewritten.

The plugin filename is contained within the cache file so that in case the
cache file's filename ever gets changed, it is still possible to work out
which plugins' data it holds.

Each cache file will be able to store up to ~10^7 entries, though the
probability of there being a CRC collision reaches 1% at ~10^4 entries, due
to the birthday problem. Still, it's unlikely that there will ever be
several thousand versions of a file with the same filename in use, so it's
probably not worth worrying about.


Single vs. Multi-File
---------------------

A single-file cache would use the above structure, but with an additional
uint64_t in each index entry to store a filename hash, and without the filename
at the start of the file.

Let's say the cache file holds info for 100,000 plugins (25,000 mods, each
with two plugins, and having two versions released - probably still a
conservative estimate). Assuming each plugin changes 10 records, and has 2
masters with filenames 10 characters long, the size is ~11.4 MB.

Using a multi-file cache and the same assumptions being made as above,
the size of each file will be 390 bytes.

However, because we're dealing with lots of small files, HTTP request/response
time has to be accounted for. Google says that the best average for the
upload/download speed ratio of most Internet connections is 1:4, and that
headers are roughly 300 bytes long without cookies. Each file's effective size
is therefore 1890 bytes.

For a load order of 250 plugins, the total effective size is ~461 kB. This is
~25x smaller than the equivalent single-file cache that would need to be
transferred, but it doesn't take into account the HTTP connection time, which
is significant for small files. I don't know how I can take that into account,
but if I've understood things correctly, I don't need to, as a persistent
connection could be used, which would require only one HTTP connection to be
made. HTTP pipelining could also be used to improve performance. A multi-file
cache could also be cached, with new files only being downloaded if they had
changed or weren't already on the user's system, rather than the whole cache
having to be re-downloaded even if the only change was the addition of a plugin
the user doesn't have. This would only save 95 kB over the assumed load order at
maximum though.

Given all that, it's probably better to use a multi-file cache over a single
file cache.
