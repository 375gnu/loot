LOOT Masterlist File Format
===========================

In YAML, the message object is:
---
!message:
    condition: OPTIONAL !condition
    type: REQUIRED !!string
    content: REQUIRED !!string
...
Allowed values for the 'type' node are "SAY", "WARN" or "ERROR". The semantics
of the types are:
	say		Generic message type, carries no semantics.
	warn	A warning message, detailing a non-critical installation issue.
	error	An error message, detailing a critical installation issue.
	
The 'content' node string will treat all file:// , http:// and https:// links as
hyperlinks. A link can be given a label by enclosing it and the label in double
quotes, eg. "http://www.example.com example link".


The file object:
---
!file:
	condition: OPTIONAL !condition
	name: REQUIRED !!string
	ver: OPTIONAL !!int or !!string
	mod: OPTIONAL !!string
...
CRCs are given as hex integers prefixed by 0x. The 'mod' node allows the name
of the parent mod to be used instead of the filename in messages.


The condition object:
---
!condition:
   	exp: REQUIRED !!string
   	vars: REQUIRED [!file or !!string]
...
The [] denotes a list of the given type(s).
All 'file' objects used in a condition must have empty 'condition' nodes to
prevent recursion loops.
All conditions will have their results cached.
The 'exp' string must follow the following format:

IF|IFNOT FILE|VERSION|ACTIVE|LANG [AND|OR IF|IFNOT FILE|VERSION|ACTIVE|LANG]*

The four condition types are detailed below:
	Type	Args			Details
	FILE	!file			If the file object passed contains a CRC, this 
							condition checks for a CRC match, otherwise it 
							checks for existence.
	VERSION	!file, !!string	The 'ver' node of the file object must contain
							a version string. The string argument is '<', '=' or
							'>', and is used to form an expression with the true
							version on the left and the given version on the
							right, which is then checked to see if it holds.
	ACTIVE	!file			Checks if the given file is a plugin, and if that
							plugin is active.
	LANG	!!string		Checks to see if the given language string matches
							the current language.

The 'vars' node lists the variables that are used in the expression in the order
that they are to be used.

The plugin object:
---
!plugin:
	name: REQUIRED !!string
	priority: OPTIONAL !undecided
	reqs: OPTIONAL [!file]
	incs: OPTIONAL [!file]
	msgs: OPTIONAL [!message]
...
The 'name' node can be either an exact filename or a regular expression. The 
difference will be determined by looking for the "\.esp" or "\.esm" substrings, 
which are only valid for a regular expression.
The type of the 'priority' node has not been decided yet, as it's not yet clear
how much fidelity is required for it.
If any of the 'reqs' node objects are not present, an error message will be
displayed. If any of the 'incs' node objects are present, an error message will
be displayed.
The 'reqs' node objects must be listed in load order. The 'reqs' and 'incs'
nodes may contain a mix of plugin and non-plugin objects.


LOOT Userlist Format
====================

Same as masterlist format, but the plugin object is:
---
!plugin:
	name: REQUIRED !!string
	priority: OPTIONAL !undecided
	enabled: OPTIONAL !bool
	after: OPTIONAL !!string
	reqs: OPTIONAL [!file]
	incs: OPTIONAL [!file]
	msgs: OPTIONAL [!message]
...
If the 'enabled' node is not specified, its value is assumed true. The 'after'
node is a tentative implementation of how users will specify custom positions,
and will take the filename of the plugin that the object plugin will load after.


Examples
========

Simple Example
--------------

---
- name: MyMod.esp
  req:
    - name: AnotherMod.esp
    - name: AnotherModPatch.esp
  msg:
    - type: say
      content: "This is my mod."
    - type: say
      content: "This is a second message."
...

Complex Example
---------------

---
# Note that classes are not specified, YAML will treat them as assoc. arrays,
# LOOT will assume they are file objects.
filevars:
  - &GAME name: "TESV.exe"
  - &MASTER {name: "Oblivion.esm", ver: "1.2.416"}
  - &SE name: "obse_loader.exe"
  - &TEST {name: "Test.esp", ver: 0x0537AB3C}
  - &SE20 <<: [*SE, ver: "0.0.20.1"]

msgvars:
  - &OBSOLETE {type: SAY, content: "Obsolete. Remove and upgrade to the latest version."}

globals:
  - {type: SAY, content: "You're using LOOT!"}

- name: Oblivion.esm
  msg:
    - {condition: {exp: IF FILE, vars: *GAME}, type: WARN, content: "False alarm."}
    - <<: {*OBSOLETE, content: Quotes aren't necessary, unless the message contains special chars. }
...


LOOT Machine Database Format
============================

The formatting of this database doesn't need to be human-readable, but must 
contain the following information for each plugin:

  * Filename (for roughly identifying the file)
  * CRC	(for precisely identifying the exact file)
  * Masters in the order they appear in the plugin's master list.
  * FormIDs of the records it edits (not added records).
  
Rather than have a single database file, it is more efficient past the short
term to use a different file for each plugin filename's data, even after taking
into account the additional networking cost of using many small files. See
the section after the divider below for the analysis.

Each database file will be named filename.txt, where filename is a plugin
filename including extension, eg. "Unofficial Oblivion Patch.esp.txt". In each
database file, the data will be divided into entries for each of the different
versions of that file, which are handled using their CRCs. These entries make
up the bulk of the file, and are followed by an index of CRCs and offsets to
their corresponding data at the end of the file.

	Name			Type					Details
	---------------------------------------------------------------------------
	Data Entries	data entry[Entry Count]		
	Index			index entry[Entry Count]
	Entry Count		uint32_t
	
Each data entry has the following structure:

	Name			Type					Details
	---------------------------------------------------------------------------
	Size			uint32_t				Total size of data entry, not
											including this value.
	Masters Length	uint16_t				Includes null characters.
	Masters			char[Masters Length]	Null-terminated filenames in order
											of how they appeared in the plugin.
	FormIDs			uint32_t[len]			len = (Size - Masters Length) / 4

Each index entry has the following structure:

	Name			Type					Details
	---------------------------------------------------------------------------
	File CRC		uint32_t
	Data offset		uint32_t				From beginning of file.
	
All numbers are encoded low to high byte. All strings are encoded in UTF-8.

The reason for this structure is to optimise the processes that will be
performed upon database files: searching, reading data and appending new data.
The index allows quick searching of the file as it is composed of a given
number of entries with defined size. It is located at the end of the file rather
than the more usual beginning so that appending new data does not need to
rewrite the whole file to also update the index: only the index will ever be
rewritten.

Each database file will be able to store up to ~10^7 entries, though the
probability of there being a CRC collision reaches 1% at ~10^4 entries, due to
the birthday problem. Still, it's unlikely that there will ever be several
thousand versions of a file with the same filename in use, so it's probably not
worth worrying about.


Single vs. Multi-File
---------------------

A single-file database would use the above structure, but with an additional
uint64_t in each index entry to store a filename hash.

Let's say the database file holds info for 100,000 plugins (25,000 mods, each
with two plugins, and having two versions released - probably still a
conservative estimate). Assuming each plugin changes 10 records, and has 2 
masters with filenames 10 characters long, the size is ~11.4 MB.

Using a multi-file database and the same assumptions being made as above, 
the size of each file will be 390 bytes.

However, because we're dealing with lots of small files, HTTP request/response
time has to be accounted for. Google says that the best average for the 
upload/download speed ratio of most Internet connections is 1:4, and that 
headers are roughly 300 bytes long without cookies. Each file's effective size 
is therefore 1890 bytes. 

For a load order of 250 plugins, the total effective size is ~461 kB. This is
~25x smaller than the equivalent single-file database that would need to be
transferred, but it doesn't take into account the HTTP connection time, which
is significant for small files. I don't know how I can take that into account,
but if I've understood things correctly, I don't need to, as a persistent
connection could be used, which would require only one HTTP connection to be
made. HTTP pipelining could also be used to improve performance. A multi-file 
database could also be cached, with new files only being downloaded if they had 
changed or weren't already on the user's system, rather than the whole database 
having to be re-downloaded even if the only change was the addition of a plugin 
the user doesn't have. This would only save 95 kB over the assumed load order at 
maximum though.

Given all that, it's probably better to use a multi-file database over a single
file database.
