<!--
<plugin-card> element. It fires the following custom events:

-->

<template id="pluginCard">
    <style>
    @import 'css/font-awesome.min.css';
    :host {
        display: block;
        background:white;
        margin:1em;
        box-shadow: 0 2px 5px 0 rgba(0, 0, 0, 0.26);
        padding:1em;
        position: relative;
        overflow:visible;
        transition: 0.6s;
        transform-style: preserve-3d;
    }
    :host([data-active=false]) #activeTick {
        visibility: hidden;
    }
    :host([data-bsa=false]) #icons #loadsBSA {
        display: none;
    }
    :host([data-dummy=false]) #icons #dummyPlugin {
        display: none;
    }
    :host([data-edits=false]) #icons #hasUserEdits {
        display: none;
    }

    #front, #editor {
        display: block;
    }

    #editor {
        transform: rotateY(180deg) translateZ(1px);
        display:none;
    }

    :host(.flip) {
        transform: rotateY(180deg);
    }

    :host(.flip) #front  {
        display: none;
    }

    :host(.flip) #editor  {
        display: block;
    }

    #icons {
        background: transparent;
        margin: 0;
        padding: 0;
        list-style-type: none;
        position: absolute;
        top: 1em;
        right: 0.5em;
        overflow:visible;
    }
    #icons .fa {
        color: grey;
        text-align: center;
        display: inline-block;
        margin: 0.2em;
    }
    #icons > li:hover {
        color: black;
    }
    #menuButton {
        width: 1.5em;
        text-align: center;
        margin: 0.2em;
        cursor: pointer;
    }
    ::content h1, h1 {
        margin: 0;
        font-weight: normal;
        font-size: 1.2em;
        display: inline-block;
    }
    ::content .version, .version {
        display: inline-block;
        margin-left: 1em;
        color:#6394F8;
    }
    ::content .crc, .crc {
        display: inline-block;
        margin-left: 1em;
        color:#BC8923;
    }
    .hidden, ::content .hidden {
        display: none;
    }
    #activeTick {
        color: green;
        padding-right: 0.5em;
    }

    #tableTabs {
        margin: 1.5em 1em;
        display: table;
    }
    #tableTabs > span {
        display: inline-block;
        padding: 0.5em;
        border: 1px black solid;
        border-bottom: none;
        background: #e3e3e3;
        cursor: pointer;
    }
    #tableTabs > span:not(:first-child) {
        border-left: none;
    }
    #tableTabs > span:hover, #tableTabs span.selected {
        background: #f8f8f8;
    }
    #tableTabs .editable {
        margin: 0;
        border-collapse: collapse;
        border: 1px black solid;
        width: 100%;
    }

    #enableEdits {
        margin-bottom: 1em;
    }
    label[for=priorityValue] {
        margin-left: 0.5em;
    }
    .buttons {
        text-align: right;
    }
    input[readonly] {
        border: none;
        -webkit-user-select: none;
    }
    input:invalid {
        background-color: pink;
        color: white;
    }
    td input {
        width: 100%;
        text-overflow: ellipsis;
    }
    td:last-child {
        cursor: pointer;
    }
    td:last-child:hover {
        color: red;
    }
    table {
        margin: 3em 1em;
        border-collapse: collapse;
    }
    td, th {
        vertical-align: top;
        text-align: left;
        padding: 0.5em;
    }
    th {
        border-bottom: 1px black solid;
    }
    tbody tr:last-child {
        cursor: pointer;
        color: grey;
    }
    tbody tr:last-child:hover {
        color: black;
    }
    input[type='checkbox'] {
        position:relative;
        top:0.15em;
        margin-left:0.5em;
    }

    #menu {
        background: white;
        box-shadow:0 0 3px 0px rgba(0,0,0,0.5);
        font:10pt/1.5 Helvetica,sans-serif;
        position: absolute;
        right: 1em;
        width: 14em;
        text-align: left;
        padding:0;
    }
    #menu div, #menu label {
        padding: 0.2em 0.5em;
        cursor: pointer;
        display: block;
    }
    #menu div:hover, #menu label:hover {
        background: #e3e3e3;
    }
    #menu span {
        padding-right: 0.4em;
    }
    #menu input {
        position: relative;
        top: 0.15em;
        margin: 0em 0.3em 0 0.1em;
    }
    #menu .disabled {
        cursor: default;
        color: #999;
    }
    </style>

    <section id="front">
        <span id="activeTick" class="fa fa-check" title="Active Plugin"></span>
        <content select="h1"></content>
        <content select=".version"></content>
        <content select=".crc"></content>
        <content select=".tag.add"></content>
        <content select=".tag.remove"></content>
        <content select="ul"></content>
        <ol id="icons">
            <li id="dummyPlugin" class="fa fa-eye-slash" title="Dummy Plugin"></li>
            <li id="loadsBSA" class="fa fa-paperclip" title="Loads BSA"></li>
            <li id="hasUserEdits" class="fa fa-user" title="Has User Metadata"></li>
            <li id="menuButton" class="fa fa-ellipsis-v fa-lg" title="Click to open the plugin menu.">
                <div id="menu" class="hidden">
                    <label><input type="checkbox" id="showOnlyConflicts" class="fa-fw">Show Only Conflicts</label>
                    <div id="editMetadata"><span class="fa fa-pencil fa-fw"></span>Edit Metadata</div>
                    <div id="copyMetadata"><span class="fa fa-copy fa-fw"></span>Copy Metadata As Text</div>
                    <div id="clearMetadata"><span class="fa fa-trash-o fa-fw"></span>Clear User Metadata</div>
                </div>
            </li>
        </ol>
    </section>
    <section id="editor">
        <h1></h1>
        <span class="version"></span>
        <span class="crc"></span>
        <div>
            <input type="checkbox" id="enableEdits">
            <label for="enableEdits">Enable Edits</label><br>
            <input type="checkbox" id="globalPriority">
            <label for="globalPriority" title="Global priorities are compared against all other plugins. Normal priorities are compared against only conflicting plugins.">Global Priority</label><br>
            <label for="priorityValue">Priority Value</label>
            <input id="priorityValue" type="number" max="999999" min="-999999" step="1" value="0">
        </div>
        <div id="tableTabs">
            <span class="selected" data-for="loadAfter">Load After</span>
            <span data-for="req">Requirements</span>
            <span data-for="inc">Incompatibilities</span>
            <span data-for="message">Messages</span>
            <span data-for="tags">Bash Tags</span>
            <span data-for="dirty">Dirty Info</span>
            <span data-for="locations">Locations</span>

            <table is="editable-table" id="loadAfter" data-template="fileRow">
                <thead>
                    <tr><th>Filename</th><th>Display Name</th><th>Condition</th><th></th></tr>
                </thead>
                <tbody>
                    <!-- File rows go here. -->
                    <tr><td colspan="4">Add new row...</td><td></td></tr>
                </tbody>
            </table>
            <table is="editable-table" id="req" class="hidden" data-template="fileRow">
                <thead>
                    <tr><th>Filename</th><th>Display Name</th><th>Condition</th><th></th></tr>
                </thead>
                <tbody>
                    <!-- File rows go here. -->
                    <tr><td colspan="4">Add new row...</td><td></td></tr>
                </tbody>
            </table>
            <table is="editable-table" id="inc" class="hidden" data-template="fileRow">
                <thead>
                    <tr><th>Filename</th><th>Display Name</th><th>Condition</th><th></th></tr>
                </thead>
                <tbody>
                    <!-- File rows go here. -->
                    <tr><td colspan="4">Add new row...</td><td></td></tr>
                </tbody>
            </table>
            <table is="editable-table" id="message" class="hidden" data-template="messageRow">
                <thead>
                    <tr><th>Type</th><th>Content</th><th>Condition</th><th>Language</th><th></th></tr>
                </thead>
                <tbody>
                    <!-- Message rows go here. -->
                    <tr><td colspan="4">Add new row...</td><td></td></tr>
                </tbody>
            </table>
            <table is="editable-table" id="tags" class="hidden" data-template="tagRow">
                <thead>
                    <tr><th>Add/Remove</th><th>Bash Tag</th><th>Condition</th><th></th></tr>
                </thead>
                <tbody>
                    <!-- Bash Tag rows go here. -->
                    <tr><td colspan="4">Add new row...</td><td></td></tr>
                </tbody>
            </table>
            <table is="editable-table" id="dirty" class="hidden" data-template="dirtyInfoRow">
                <thead>
                    <tr><th>CRC</th><th>ITM Count</th><th>Deleted References</th><th>Deleted Navmeshes</th><th>Cleaning Utility</th><th></th></tr>
                </thead>
                <tbody>
                    <!-- Dirty info rows go here. -->
                    <tr><td colspan="4">Add new row...</td><td></td></tr>
                </tbody>
            </table>
            <table is="editable-table" id="locations" class="hidden" data-template="locationRow">
                <thead>
                    <tr><th>URL</th><th>Version</th><th></th></tr>
                </thead>
                <tbody>
                    <!-- Location rows go here. -->
                    <tr><td colspan="3">Add new row...</td><td></td></tr>
                </tbody>
            </table>
        </div>
        <hr>
        <div id="buttons">
            <button id="accept">Apply</button>
            <button id="cancel">Cancel</button>
        </div>
    </section>
</template>

<script>
'use strict';
// Record this document.
var pluginCardImportDoc = document.currentScript.ownerDocument;

/* Create a <plugin-card> element type. */
var pluginCardProto = Object.create(HTMLElement.prototype, {

    getName: {
        value: function() {
            return this.getElementsByTagName('h1')[0].textContent;
        }
    },

    showEditorTable: {
        value: function(evt) {
            var tableId = evt.target.getAttribute('data-for');
            var tables = evt.target.parentElement.parentElement.getElementsByTagName('table');
            for (var i = 0; i < tables.length; ++i) {
                if (tables[i].id != tableId) {
                    hideElement(tables[i]);
                } else {
                    showElement(tables[i]);
                }
            }
            evt.target.parentElement.getElementsByClassName('selected')[0].classList.toggle('selected');
            evt.target.classList.toggle('selected');
        }
    },

    readFromEditor: {
        value: function() {
            /* Need to turn all the editor controls' values into data to
               process. The control values can be compared with the existing
               values to determine what's been changed, and masterlist rows in
               the tables can be ignored because they're immutable. */

            var plugin = {
                name: this.getElementsByTagName('h1')[0].textContent,
                userlist: {},
            };

            /* First find the corresponding plugin. */
            for (var i = 0; i < loot.game.plugins.length; ++i) {
                if (loot.game.plugins[i].id == this.id) {

                    /* If either of the priority values have been changed, the
                       base priority value they're derived from will have
                       changed, so record both. */
                    if (this.shadowRoot.getElementById('globalPriority').checked != loot.game.plugins[i].isGlobalPriority
                        || this.shadowRoot.getElementById('priorityValue').value != loot.game.plugins[i].modPriority) {
                        plugin.isGlobalPriority = this.shadowRoot.getElementById('globalPriority').checked;
                        plugin.modPriority = this.shadowRoot.getElementById('priorityValue').value;
                    }

                    plugin.userlist.enabled = this.shadowRoot.getElementById('enableEdits').checked;

                    var tables = this.shadowRoot.getElementsByTagName('table');
                    for (var j = 0; j < tables.length; ++j) {
                        var rowsData = tables[j].getRowsData(true);
                        if (rowsData.length > 0) {
                            if (tables[j].id == 'loadAfter') {
                                plugin.userlist.after = rowsData;
                            } else if (tables[j].id == 'req') {
                                plugin.userlist.req = rowsData;
                            } else if (tables[j].id == 'inc') {
                                plugin.userlist.inc = rowsData;
                            } else if (tables[j].id == 'message') {
                                rowsData.forEach(function(data){
                                    data.content = [{
                                        str: data.content,
                                        lang: data.language
                                    }]
                                    delete data.language;
                                });
                                plugin.userlist.msg = rowsData;
                            } else if (tables[j].id == 'tags') {
                                rowsData.forEach(function(data){
                                    data = loot.game.plugins[i].convTagObj(data);
                                });
                                plugin.userlist.tag = rowsData;
                            } else if (tables[j].id == 'dirty') {
                                rowsData.forEach(function(data){
                                    data.crc = parseInt(data.crc, 16);
                                });
                                plugin.userlist.dirty = rowsData;
                            } else if (tables[j].id == 'locations') {
                                rowsData.forEach(function(data){
                                    /* User metadata can only specify one version, but it should be a list. */
                                    if (data.ver.length > 0) {
                                        data.ver = [
                                            data.ver
                                        ];
                                    } else {
                                        delete data.ver;
                                    }
                                });
                                plugin.userlist.url = rowsData;
                            }
                        }
                    }

                    /* Now update JS userlist data for the plugin. */
                    loot.game.plugins[i].userlist = plugin.userlist;

                    break;
                }
            }
            return plugin;
        }
    },

    hideEditor: {
        value: function(evt) {
            var card = evt.target.parentElement.parentElement.parentNode.host;
            var isValid = true;
            if (evt.target.id == 'accept') {
                /* First validate table inputs. */
                var inputs = evt.target.parentElement.parentElement.getElementsByTagName('input');
                for (var i = 0; i < inputs.length; ++i) {
                    if (!inputs[i].checkValidity()) {
                        isValid = false;
                        console.log(inputs[i]);
                    }
                }

                if (isValid) {
                    /* Need to record the editor control values and work out what's
                       changed, and update any UI elements necessary. Offload the
                       majority of the work to the C++ side of things. */
                    var request = JSON.stringify({
                        name: 'editorClosed',
                        args: [
                            card.readFromEditor()
                        ]
                    });
                    loot.query(request).then(JSON.parse).then(function(result){
                        if (result) {
                            for (var i = 0; i < loot.game.plugins.length; ++i) {
                                if (loot.game.plugins[i].id == card.id) {

                                    loot.game.plugins[i].modPriority = result.modPriority;
                                    loot.game.plugins[i].isGlobalPriority = result.isGlobalPriority;
                                    loot.game.plugins[i].messages = result.messages;
                                    loot.game.plugins[i].tags = result.tags;
                                    loot.game.plugins[i].isDirty = result.isDirty;

                                    break;
                                }
                            }
                        }
                    }).catch(processCefError);
                }
            }
            if (isValid) {

                /* Remove table tab event handlers. */
                var elements = card.shadowRoot.getElementById('tableTabs').children;
                for (var i = 0; i < elements.length; ++i) {
                    if (elements[i].hasAttribute('data-for')) {
                        elements[i].removeEventListener('click', card.showEditorTable, false);
                    }
                }

                /* Remove button event handlers. */
                card.shadowRoot.getElementById('accept').removeEventListener('click', card.hideEditor, false);
                card.shadowRoot.getElementById('cancel').removeEventListener('click', card.hideEditor, false);


                /* Remove drag 'n' drop event handlers. */
                var elements = document.getElementById('pluginsNav').children;
                for (var i = 0; i < elements.length; ++i) {
                    elements[i].removeAttribute('draggable');
                    elements[i].removeEventListener('dragstart', elements[i].handleDragStart, false);
                }

                /* Disable priority hover in plugins list and enable header
                   buttons if this is the only editor instance. */
                var numEditors = parseInt(document.body.getAttribute('data-editors'), 10);
                --numEditors;

                if (numEditors == 0) {
                    document.body.classList.remove('editMode');
                }
                document.body.setAttribute('data-editors', numEditors);

                /* Hide editor. */
                card.classList.toggle('flip');
            }
        }
    },

    showEditor: {
        value: function(evt) {
            var pluginCard = evt.target.parentElement.parentElement.parentElement.parentElement.parentNode.host;

            /* Fill editor controls with values from the plugin this card corresponds to. */

            /* First find the corresponding plugin. */
            for (var i = 0; i < loot.game.plugins.length; ++i) {
                if (loot.game.plugins[i].id == pluginCard.id) {

                    pluginCard.shadowRoot.getElementById('editor').getElementsByTagName('h1')[0].textContent = loot.game.plugins[i].name;
                    pluginCard.shadowRoot.getElementById('editor').getElementsByClassName('version')[0].textContent = loot.game.plugins[i].version;
                    if (loot.game.plugins[i].crc != '0') {
                        pluginCard.shadowRoot.getElementById('editor').getElementsByClassName('crc')[0].textContent = loot.game.plugins[i].crc.toString(16).toUpperCase();
                    }

                    /* Fill in the editor input values. */
                    if (loot.game.plugins[i].userlist && !loot.game.plugins[i].userlist.enabled) {
                        pluginCard.shadowRoot.getElementById('enableEdits').checked = false;
                    } else {
                        pluginCard.shadowRoot.getElementById('enableEdits').checked = true;
                    }
                    pluginCard.shadowRoot.getElementById('globalPriority').checked = loot.game.plugins[i].isGlobalPriority;
                    pluginCard.shadowRoot.getElementById('priorityValue').value = loot.game.plugins[i].modPriority;

                    /* Clear any existing editor table data. Don't remove the last row though,
                       that's the "add new row" one. */
                    var tables = pluginCard.shadowRoot.getElementsByTagName('table');
                    for (var j = 0; j < tables.length; ++j) {
                        tables[j].clear();
                    }

                    /* Fill in editor table data. Masterlist-originated rows should have
                       their contents made read-only, and be unremovable. */
                    var tables = pluginCard.shadowRoot.getElementsByTagName('table');
                    for (var j = 0; j < tables.length; ++j) {
                        if (tables[j].id == 'loadAfter') {

                            if (loot.game.plugins[i].masterlist && loot.game.plugins[i].masterlist.after) {
                                loot.game.plugins[i].masterlist.after.forEach(function(file) {
                                    var row = tables[j].addRow(file);
                                    tables[j].setReadOnly(row);
                                });
                            }
                            if (loot.game.plugins[i].userlist && loot.game.plugins[i].userlist.after) {
                                loot.game.plugins[i].userlist.after.forEach(function(file) {
                                    tables[j].addRow(file);
                                });
                            }

                        } else if (tables[j].id == 'req') {

                            if (loot.game.plugins[i].masterlist && loot.game.plugins[i].masterlist.req) {
                                loot.game.plugins[i].masterlist.req.forEach(function(file) {
                                    var row = tables[j].addRow(file);
                                    tables[j].setReadOnly(row);
                                });
                            }
                            if (loot.game.plugins[i].userlist && loot.game.plugins[i].userlist.req) {
                                loot.game.plugins[i].userlist.req.forEach(function(file) {
                                    tables[j].addRow(file);
                                });
                            }

                        } else if (tables[j].id == 'inc') {

                            if (loot.game.plugins[i].masterlist && loot.game.plugins[i].masterlist.inc) {
                                loot.game.plugins[i].masterlist.inc.forEach(function(file) {
                                    var row = tables[j].addRow(file);
                                    tables[j].setReadOnly(row);
                                });
                            }
                            if (loot.game.plugins[i].userlist && loot.game.plugins[i].userlist.inc) {
                                loot.game.plugins[i].userlist.inc.forEach(function(file) {
                                    tables[j].addRow(file);
                                });
                            }

                        } else if (tables[j].id == 'message') {

                            if (loot.game.plugins[i].masterlist && loot.game.plugins[i].masterlist.msg) {
                                loot.game.plugins[i].masterlist.msg.forEach(function(message) {
                                    var data = {
                                        type: message.type,
                                        content: message.content[0].str,
                                        condition: message.condition,
                                        language: message.content[0].lang
                                    };
                                    var row = tables[j].addRow(data);
                                    tables[j].setReadOnly(row);

                                });
                            }
                            if (loot.game.plugins[i].userlist && loot.game.plugins[i].userlist.msg) {
                                loot.game.plugins[i].userlist.msg.forEach(function(message) {
                                    var data = {
                                        type: message.type,
                                        content: message.content[0].str,
                                        condition: message.condition,
                                        language: message.content[0].lang
                                    };
                                    tables[j].addRow(data);
                                });
                            }

                        } else if (tables[j].id == 'tags') {

                            if (loot.game.plugins[i].masterlist && loot.game.plugins[i].masterlist.tag) {
                                loot.game.plugins[i].masterlist.tag.forEach(function(tag) {
                                    var data = loot.game.plugins[i].convTagObj(tag);
                                    var row = tables[j].addRow(data);
                                    tables[j].setReadOnly(row);
                                }, loot.game.plugins[i]);
                            }
                            if (loot.game.plugins[i].userlist && loot.game.plugins[i].userlist.tag) {
                                loot.game.plugins[i].userlist.tag.forEach(function(tag) {
                                    var data = loot.game.plugins[i].convTagObj(tag);
                                    tables[j].addRow(data);
                                }, loot.game.plugins[i]);
                            }

                        } else if (tables[j].id == 'dirty') {

                            if (loot.game.plugins[i].masterlist && loot.game.plugins[i].masterlist.dirty) {
                                loot.game.plugins[i].masterlist.dirty.forEach(function(info) {
                                    info.crc = info.crc.toString(16).toUpperCase();
                                    var row = tables[j].addRow(info);
                                    tables[j].setReadOnly(row);
                                });
                            }
                            if (loot.game.plugins[i].userlist && loot.game.plugins[i].userlist.dirty) {
                                loot.game.plugins[i].userlist.dirty.forEach(function(info) {
                                    info.crc = info.crc.toString(16).toUpperCase();
                                    tables[j].addRow(info);
                                });
                            }

                        } else if (tables[j].id == 'locations') {

                            if (loot.game.plugins[i].masterlist && loot.game.plugins[i].masterlist.url) {
                                loot.game.plugins[i].masterlist.url.forEach(function(location) {
                                    var temp = location;
                                    if (temp.ver) {
                                        temp.ver = temp.ver[0];
                                    }
                                    var row = tables[j].addRow(temp);
                                    tables[j].setReadOnly(row);
                                });
                            }
                            if (loot.game.plugins[i].userlist && loot.game.plugins[i].userlist.url) {
                                loot.game.plugins[i].userlist.url.forEach(function(location) {
                                    var temp = location;
                                    if (temp.ver) {
                                        temp.ver = temp.ver[0];
                                    }
                                    tables[j].addRow(temp);
                                });
                            }

                        }
                    }
                    break;
                }
            }

            /* Set up table tab event handlers. */
            var elements = pluginCard.shadowRoot.getElementById('tableTabs').children;
            for (var i = 0; i < elements.length; ++i) {
                if (elements[i].hasAttribute('data-for')) {
                    elements[i].addEventListener('click', pluginCard.showEditorTable, false);
                }
            }

            /* Set up button event handlers. */
            pluginCard.shadowRoot.getElementById('accept').addEventListener('click', pluginCard.hideEditor, false);
            pluginCard.shadowRoot.getElementById('cancel').addEventListener('click', pluginCard.hideEditor, false);

            /* Set up drag 'n' drop event handlers. */
            elements = document.getElementById('pluginsNav').children;
            for (var i = 0; i < elements.length; ++i) {
                elements[i].draggable = true;
                elements[i].addEventListener('dragstart', elements[i].handleDragStart, false);
            }

            /* Enable priority hover in plugins list and enable header
               buttons if this is the only editor instance. */
            var numEditors = 0;
            if (document.body.hasAttribute('data-editors')) {
                numEditors = parseInt(document.body.getAttribute('data-editors'), 10);
            }
            ++numEditors;

            if (numEditors == 1) {
                document.body.classList.add('editMode');
            }
            document.body.setAttribute('data-editors', numEditors);

            /* Now show editor. */
            pluginCard.classList.toggle('flip');
        }
    },

    onShowOnlyConflicts: {
        value: function(evt) {
            /* Depending on what was clicked, this function may be run before
               the checkbox state has updated. Handle both cases. */
            var activateFilter, card;
            if (evt.currentTarget == evt.target) {
                /* Clicked on the label, checkbox state isn't updated yet. */
                activateFilter = !evt.target.firstElementChild.checked;
                card = evt.target.parentElement.parentElement.parentElement.parentElement.parentNode.host;
            } else {
                /* Clicked on the checkbox. */
                activateFilter = evt.target.checked;
                card = evt.target.parentElement.parentElement.parentElement.parentElement.parentElement.parentNode.host;
            }
            if (activateFilter) {
                /* Un-highlight any existing filter plugin. */
                var cards = document.getElementsByTagName('main')[0].getElementsByTagName('plugin-card');
                for (var i = 0; i < cards.length; ++i) {
                    cards[i].classList.toggle('highlight', false);
                }
                card.classList.toggle('highlight', true);
                document.body.setAttribute('data-conflicts', card.getName());
            } else {
                card.classList.toggle('highlight', false);
                document.body.removeAttribute('data-conflicts');
            }
            applyFilters(evt);
        }
    },

    onCopyMetadata: {
        value: function(evt) {
            var card = evt.target.parentElement.parentElement.parentElement.parentElement.parentNode.host;
            var request = JSON.stringify({
                name: 'copyMetadata',
                args: [
                    card.getName()
                ]
            });

            loot.query(request).catch(processCefError);
        }
    },

    onClearMetadata: {
        value: function(evt) {
            var pluginCard = evt.target.parentElement.parentElement.parentElement.parentElement.parentNode.host;

            showMessageDialog('Clear Plugin Metadata', 'Are you sure you want to clear all existing user-added metadata from "' + pluginCard.getName() + '"?', function(result){
                if (result) {
                    var request = JSON.stringify({
                        name: 'clearPluginMetadata',
                        args: [
                            pluginCard.getName()
                        ]
                    });

                    loot.query(request).then(JSON.parse).then(function(result){
                        if (result) {
                            /* Need to empty the UI-side user metadata. */
                            for (var i = 0; i < loot.game.plugins.length; ++i) {
                                if (loot.game.plugins[i].id == pluginCard.id) {
                                    loot.game.plugins[i].userlist = undefined;

                                    loot.game.plugins[i].modPriority = result.modPriority;
                                    loot.game.plugins[i].isGlobalPriority = result.isGlobalPriority;
                                    loot.game.plugins[i].messages = result.messages;
                                    loot.game.plugins[i].tags = result.tags;
                                    loot.game.plugins[i].isDirty = result.isDirty;

                                    break;
                                }
                            }
                        }
                    }).catch(processCefError);
                }
            });
        }
    },

    onMenuButtonClick: {
        value: function(evt) {
            /* Open the plugin menu. */
            evt.currentTarget.firstElementChild.classList.toggle('hidden');
        }
    },

    createdCallback: {
        value: function() {

            var template = pluginCardImportDoc.getElementById('pluginCard');
            var clone = document.importNode(template.content, true);

            this.createShadowRoot().appendChild(clone);

            var h1 = document.createElement('h1');
            this.appendChild(h1);
            var crc = document.createElement('div');
            crc.className = 'crc';
            this.appendChild(crc);
            var version = document.createElement('div');
            version.className = 'version';
            this.appendChild(version);

            var tagAdd = document.createElement('div');
            tagAdd.className = 'tag add';
            this.appendChild(tagAdd);
            var tagRemove = document.createElement('div');
            tagRemove.className = 'tag remove';
            this.appendChild(tagRemove);

            var messages = document.createElement('ul');
            this.appendChild(messages);
        }
    },

    attachedCallback: {
        value: function() {
            this.shadowRoot.getElementById('menuButton').addEventListener('click', this.onMenuButtonClick, false);

            var hoverTargets = this.shadowRoot.querySelectorAll('[title]');
            for (var i = 0; i < hoverTargets.length; ++i) {
                hoverTargets[i].addEventListener('mouseenter', showHoverText, false);
                hoverTargets[i].addEventListener('mouseleave', hideHoverText, false);
            }

            /* Add event listeners for the menu items. */
            /* For some reason clicking on the label is processed slower
               than the checkbox state, and in the time difference the menu
               gets closed, so that the conflicts filter never gets applied.
               To get around this, listen for a click on the label rather
               than for checkbox state change. */
            if (document.body.getAttribute('data-conflicts') == this.getName()) {
                this.shadowRoot.getElementById('showOnlyConflicts').checked = true;
            }
            this.shadowRoot.getElementById('showOnlyConflicts').parentElement.addEventListener('click', this.onShowOnlyConflicts, false);
            this.shadowRoot.getElementById('editMetadata').addEventListener('click', this.showEditor, false);
            this.shadowRoot.getElementById('copyMetadata').addEventListener('click', this.onCopyMetadata, false);
            this.shadowRoot.getElementById('clearMetadata').addEventListener('click', this.onClearMetadata, false);

            /* Because of the 3D flip effect used when accessing the editor,
               plugin menus get hidden underneath later plugin cards unless
               those cards have a lower z-index than the card the menu is part
               of. Therefore, set this card's z-index to the negative of its
               position in the plugin list.
            */
            var cards = this.parentElement.getElementsByTagName('plugin-card');
            for (var i = 0; i < cards.length; ++i) {
                if (cards[i] == this) {
                    this.style.zIndex = -1 * i;
                }
            }
        }
    },

    detachedCallback: {
        value: function() {
            this.shadowRoot.getElementById('menuButton').removeEventListener('click', this.onMenuButtonClick, false);

            var hoverTargets = this.shadowRoot.querySelectorAll('[title]');
            for (var i = 0; i < hoverTargets.length; ++i) {
                hoverTargets[i].removeEventListener('mouseenter', showHoverText, false);
                hoverTargets[i].removeEventListener('mouseleave', hideHoverText, false);
            }

            /* Remove event listeners for the menu items. */
            /* Nothing happens if we try to remove a listener that doesn't exist,
               so don't bother checking first. */
            this.shadowRoot.getElementById('showOnlyConflicts').parentElement.removeEventListener('click', this.onShowOnlyConflicts, false);
            this.shadowRoot.getElementById('editMetadata').removeEventListener('click', this.showEditor, false);
            this.shadowRoot.getElementById('copyMetadata').removeEventListener('click', this.onCopyMetadata, false);
            this.shadowRoot.getElementById('clearMetadata').removeEventListener('click', this.onClearMetadata, false);
        }
    }

});
var PluginCard = document.registerElement('plugin-card', {prototype: pluginCardProto});

</script>