LOOT
====

Introduction
============

LOOT is BOSS v3.
See BOSS: http://code.google.com/p/better-oblivion-sorting-software/

LOOT has been given a different working name because it will be a very
different program to the one that people know and love as BOSS.

LOOT is being designed from the ground up to address the shortcomings
that are inherent in how BOSS approaches load order optimisation. That's
another reason why it's being hosted on a different site, under a
different name, even though it is intended to be released as an update
to BOSS. While ideas and some code will be transferred, the distancing
will hopefully produce better results.

So what's wrong with BOSS? Why do I feel the need to go back to the
drawing board?

Well, Oblivion has accumulated around 25,000 mods on
Oblivion Nexus since its launch in 2006. Skyrim has accumulated around
19,000 mods on Skyrim Nexus since its launch in 2011. Growth models aside,
Skyrim has proved incredibly popular for modding.

For BOSS to be as useful as possible, it needs to be able to sort as many
mods as possible. For Skyrim, we're getting user submissions of mods to
be sorted faster than we can add them, and our backlog is at 3,000+
plugins and growing. That's after I've doubled the effective team size.

The BOSS team's operational model is therefore unsustainable, and has
to change. The main issue is that it takes time for us to process all
these reports, and we only have so much free time: the team itself is the
weak point in the operating chain. It's a good idea, then, to automate
as much as possible, and so reduce the need for the team to do things.

While that's being done, I might as well also make some improvements to
other areas of BOSS.


LOOT Design Overview
====================

LOOT's central design idea is that its functionality should be as independent of
external systems as possible. A system might be a human, a group of humans, or a
server somewhere. This rather vague idea can be broken down into a few design
goals:

  * LOOT should be able to figure out an optimum load order without any inputs
    other than the plugins it will order.
  * LOOT should be able to figure out a correct load order with a minimum of
    supplementary data on author intent.
  * LOOT should be able to obtain supplementary data from an arbitrary source, 
    or arbitrary sources, depending on the number of types of data.
  * LOOT's effects should be customiseable by the user.
  * LOOT should be scaleable, focussed and extensible.
  
Note that an optimum load order is not necessarily a correct load order. If 
we define the impact of a plugin as the number of its edits that get applied to
a person's game, then an optimum load order is one with the highest average
impact from its constituent plugins whilst satisfiying all explicit dependencies.
However, some plugins may be made with the intent that they are to be overridden
by others, and so a correct load order is one that also takes into account 
author intent. Given a set of plugins, their correct load order may have a lower
average impact than their optimum load order.

The design goal for a correct load order specifies the use of supplementary data
because the determination of author intent is not generally possible given only
a plugin. Such supplementary data might include any implicit masters, and
their intended order relative to any explicit masters. It might also include
whether the plugin was intended to be high or low priority.

Supplementary data can also include data not related to load ordering: one of
BOSS's great successes has been the highlighting of the issue of dirty plugins,
and the distribution of generally applicable information such as that is an
important feature to retain.

The goal of arbitrary data sources is with LOOT's long-term success in mind. It
may be that the team responsible for it may suddenly drop off the face of the
Internet, as has happened with other utilities' teams in the past. In such a
circumstance, getting access to the data source LOOT uses may be difficult or
impossible, and so anyone wishing to pick the project up would have to set up
a new source, but if LOOT can't handle arbitrary data sources, then those
picking it up would also have to release a new version of LOOT and distribute
that. This may take a while if there is nobody available with the skills or
experience required. If LOOT can handle arbitrary data sources, then all that
would need to be done is for LOOT users to be made aware of the situation, and
for them to be given instructions on how to change the source LOOT looks at in
their copies.

The goal of customiseability is because LOOT will never be able to automatically
get a load order quite how everyone wants it. There will always be an element of
choice involved in setting up a load order, so LOOT should accommodate for that.

The final goal is basically to prevent the problems BOSS has happening again, by
implementing good systems design and coding practice. I'm always learning, and
now I realise some of the decisions I made working on BOSS weren't the best. I
probably won't make the best decisions this time around either, but they should
end up better.

I anticipate that by having LOOT be able to figure out an optimum load order
without any input from humans, ordering the vast majority of plugins correctly
can be fully automated, as most plugins make a small number of changes that
are highly compatible. More complex plugins will still require the maintainance
team to provide LOOT with supplementary data, but they are relatively few.


LOOT User Experience
====================

LOOT will require a greater degree of user interaction than BOSS does,
so an interface that facilitates this is required: as such, LOOT will
not have a CLI. A GUI that accepts command line parameters may be an option if
people want one.

A general workflow for a user running LOOT to sort would be:

1. Run LOOT: it auto-sorts based on plugin content plus and masterlist
   and userlist rules.
2. LOOT finishes sorting, and displays the load order it sets.
   Clicking on a plugin in the load order will highlight all those it
   conflicts with. This provides a simple way for users to gauge conflicts
   and so decide which plugin's changes they wish to apply to their games.
   Dragging a plugin will display the positions to which it can be moved
   (by dropping it there) whilst satisfying dependencies.
   Plugins which have no conflicts are greyed out and cannot be selected,
   to simplify this process.
   There will be an information panel which will display the selected
   plugin's requirements, incompatibilities, priority and messages. These
   will be editable, upon exit of the load order window, the user will be
   asked if they wish to submit any edits they make to these fields.
   Edits to plugin positions will not be submitted.
   If LOOT encounters any errors while sorting, they are displayed instead
   of the load order.
3. The user exits the load order display, choosing either to apply or
   discard changes.
4. LOOT asks the user if they want to submit their plugin data edits. If
   so, it then asks the user to supply links for each of the plugins
   with edited data.
4. LOOT then applies the resulting load order, saves any user choices
   as userlist rules, and exits.

LOOT must also provide a means to manage user rules, to undo its
changes (only back one run though), and to edit its settings.

The Userlist Syntax and Masterlist Syntax docs will be merged into a
"Rule Syntax" doc, as the syntax will be the same for both. The new doc
will be structured so that there is a progression in complexity from
simple rule syntax to complex rule syntax as the guide progresses.

The drag 'n' drop plugin positioning will likely require userlist rules
to support positioning of plugins precisely relative to other plugins, but it
may be possible to achieve the positioning using only the priority setting. If
possible, that is preferred.


Implementation
==============

LOOT will be an ambitious project: to keep its code as simple as possible,
it will make use of external libraries to supply functionality where
possible, for example:
  * yaml-cpp: for masterlist/userlist parsing.
  * libespm: for plugin parsing.
  * libloadorder: for reading and writing load order.
  * cURL: for networking.
  * wxWidgets: for the interface.
  * Boost: for filesystem interaction, various helpful functions.

As a reflection of this, LOOT's API will provide functions only for
accessing LOOT-specific functionality and data, eg. auto-sorting,
masterlist / userlist reading, masterlist download and user
edits submission.

The support for arbitrary data sources will be implemented by having the source
LOOT uses specified in a settings file, which will be editable via the GUI.

Because auto-sorting requires LOOT to know what is inside the plugins it sorts,
it must scan the plugins, and determine which of its records are new and which
are edited (new records aren't used for determining load order). However, this
requires significant computation, so LOOT will use a database that holds which
records each plugin changes. The database will be hosted online, and will be
used in the following manner:

  1. LOOT checks to see if a database update is available, and downloads the
     update if so. This may be done by diff or by downloading the whole file if
     a diff is not feasible.
  2. LOOT scans the installed plugins, calculating the CRC of each plugin.
  3. For each plugin, the database is scanned for an entry with a matching file
     name and CRC. If an entry is found, the entry's data is used and scanning
     of the plugin is skipped.
  4. Any plugins which do not already have database entries are scanned.
  5. The correct load order of the plugins is calculated using data from scanned
     plugins, the database, the masterlist and the userlist.
  6. The data from the scanned plugins is appended to the database file, which
     is then uploaded to its hosted location.
     
In addition to having this database file as a sort of permanent and 
self-updating cache, optimisations can also be made to skip load order 
calculation. For example, if the only changes from the last load order set by
LOOT is that a plugin or plugins have been removed, then the last load order
may be used. It might also be possible to only perform partial calculation
when plugins are added, though this is not certain.

Note: For clarity, the database that holds the results of plugin scanning will
be referred to as the "machine database" (or MDB) as it will only be read and
written by the LOOT code. The list of metadata that is maintained by the LOOT
team will be referred to as the "masterlist", and the list of metadata that is
individual to each user will be referred to as the "userlist".

LOOT Masterlist & Userlist
==========================

The purpose of the masterlist is to store the following data for plugins:

  * Implicit and explicit requirements in load order.
  * Incompatibilities, for catching unresolveable conflicts.
  * Messages, for displaying information about the plugins.
  * The intended priority of the plugin relative to others that make the same
    changes.
  * Possibly also Bash Tags to be applied.
    
It is also useful to store some data not associated with plugins, such as:

  * Global messages.
  * Message objects, for reference instead of rewriting the same message
    multiple times.
  * File objects, for reference instead of rewriting the same condition
    argument multiple times.
    
All messages should also be optionally conditional on an arbitrary number of
conditions. More on that later.
    
The purpose of the userlist is to store modifications to masterlist plugin data,
and to also store user-specified positions of plugins. The userlist must also
support the disabling of plugin entries within it, so that users can turn off
their changes without deleting them.

As the masterlist and userlist are very similar, it makes sense for them to use
the same format. The userlist could then simply support two data fields that are
ignored by the masterlist parser. I think that YAML is a suitable format for
these files as it is simple, human-readable, yet quite powerful.

Further details can be found in the LOOT File Format doc.


Networking
==========

LOOT needs to be able to download and upload specific files from a VCS 
repository. (VCS to help deal with possible spam/vandalism, and to track 
changes.) It also needs to be able to send/receive data from some sort of issue
tracker.

As LOOT needs to do this for users without their own credentials for the 
repository, it needs to do this as a robot.
