LOOT
====

Introduction
============

LOOT is BOSS v3.
See BOSS: http://code.google.com/p/better-oblivion-sorting-software/

LOOT has been given a different working name because it will be a very
different program to the one that people know and love as BOSS.

LOOT is being designed from the ground up to address the shortcomings
that are inherent in how BOSS approaches load order optimisation. That's
another reason why it's being hosted on a different site, under a
different name, even though it is intended to be released as an update
to BOSS. While ideas and some code will be transferred, the distancing
will hopefully produce better results.

So what's wrong with BOSS? Why do I feel the need to go back to the
drawing board?

Well, Oblivion has accumulated around 25,000 mods on
Oblivion Nexus since its launch in 2006. Skyrim has accumulated around
19,000 mods on Skyrim Nexus since its launch in 2011. Growth models aside,
Skyrim has proved incredibly popular for modding.

For BOSS to be as useful as possible, it needs to be able to sort as many
mods as possible. For Skyrim, we're getting user submissions of mods to
be sorted faster than we can add them, and our backlog is at 3,000+
plugins and growing. That's after I've doubled the effective team size.

The BOSS team's operational model is therefore unsustainable, and has
to change. The main issue is that it takes time for us to process all
these reports, and we only have so much free time: the team itself is the
weak point in the operating chain. It's a good idea, then, to automate
as much as possible, and so reduce the need for the team to do things.

While that's being done, I might as well also make some improvements to
other areas of BOSS.


LOOT Design Overview
====================

LOOT's central design idea is that its functionality should be as independent of
external systems as possible. A system might be a human, a group of humans, or a
server somewhere. This rather vague idea can be broken down into a few design
goals:

  * LOOT should be able to figure out an optimum load order without any inputs
    other than the plugins it will order.
  * LOOT should be able to figure out a correct load order with a minimum of
    supplementary data on author intent.
  * LOOT should be able to obtain supplementary data from an arbitrary source,
    or arbitrary sources, depending on the number of types of data.
  * LOOT's effects should be customiseable by the user.
  * LOOT should be scaleable, focussed and extensible.

Note that an optimum load order is not necessarily a correct load order. If
we define the impact of a plugin as the number of its edits that get applied to
a person's game, then an optimum load order is one with the highest average
impact from its constituent plugins whilst satisfiying all explicit dependencies.
However, some plugins may be made with the intent that they are to be overridden
by others, and so a correct load order is one that also takes into account
author intent. Given a set of plugins, their correct load order may have a lower
average impact than their optimum load order.

The design goal for a correct load order specifies the use of supplementary data
because the determination of author intent is not generally possible given only
a plugin. Such supplementary data might include any implicit masters, and
their intended order relative to any explicit masters. It might also include
whether the plugin was intended to be high or low priority.

Supplementary data can also include data not related to load ordering: one of
BOSS's great successes has been the highlighting of the issue of dirty plugins,
and the distribution of generally applicable information such as that is an
important feature to retain.

The goal of arbitrary data sources is with LOOT's long-term success in mind. It
may be that the team responsible for it may suddenly drop off the face of the
Internet, as has happened with other utilities' teams in the past. In such a
circumstance, getting access to the data source LOOT uses may be difficult or
impossible, and so anyone wishing to pick the project up would have to set up
a new source, but if LOOT can't handle arbitrary data sources, then those
picking it up would also have to release a new version of LOOT and distribute
that. This may take a while if there is nobody available with the skills or
experience required. If LOOT can handle arbitrary data sources, then all that
would need to be done is for LOOT users to be made aware of the situation, and
for them to be given instructions on how to change the source LOOT looks at in
their copies.

The goal of customiseability is because LOOT will never be able to automatically
get a load order quite how everyone wants it. There will always be an element of
choice involved in setting up a load order, so LOOT should accommodate for that.

The final goal is basically to prevent the problems BOSS has happening again, by
implementing good systems design and coding practice. I'm always learning, and
now I realise some of the decisions I made working on BOSS weren't the best. I
probably won't make the best decisions this time around either, but they should
end up better.

I anticipate that by having LOOT be able to figure out an optimum load order
without any input from humans, ordering the vast majority of plugins correctly
can be fully automated, as most plugins make a small number of changes that
are highly compatible. More complex plugins will still require the maintainance
team to provide LOOT with supplementary data, but they are relatively few.


LOOT User Experience
====================

LOOT will require a greater degree of user interaction than BOSS does,
so an interface that facilitates this is required: as such, LOOT will
not have a CLI. A GUI that accepts command line parameters may be an option if
people want one.

A general workflow for a user running LOOT to sort would be:

1. Run LOOT: it auto-sorts based on plugin content plus supplementary data.
2. LOOT finishes sorting, and displays the load order it suggests. At this point
   the load order has not yet been applied.

   Clicking on a plugin in the load order will highlight all those it
   conflicts with. This provides a simple way for users to gauge conflicts
   and so decide which plugin's changes they wish to apply to their games.

   Dragging a plugin will display the positions to which it can be moved
   (by dropping it there) whilst satisfying dependencies.

   Plugins which have no conflicts are greyed out and cannot be selected,
   to simplify this process.

   There will be an information panel which will display the selected
   plugin's requirements, incompatibilities, priority and messages. These
   will be editable, and upon exit of the load order window, the user will be
   asked if they wish to submit any edits they make to these fields. Edits to
   plugin positions will not be submitted.

   If LOOT encounters any errors while sorting, they are displayed instead
   of the load order.
3. The user exits the load order display, choosing either to apply or
   discard changes.
4. LOOT asks the user if they want to submit their plugin data edits. If
   so, it then asks the user to supply links for each of the plugins
   with edited data.
4. LOOT then applies the resulting load order, saves any user choices, and
   exits.

LOOT must also provide a means to manage past user choices, to undo its
changes (only back one run though), and to edit its settings.

LOOT should ask for permission to send plugin metadata whenever there are 
metadata changes to send, unless the user selects a "do not ask me again" 
option. This setting should be configurable at any time.

Documentation will be split between three readmes: one general readme, one API
readme and one syntax readme. The version history can be split into a
fourth readme when it grows sufficiently long.


Implementation
==============

LOOT will be an ambitious project: to keep its code as simple as possible,
it will make use of external libraries to supply functionality where
possible, for example:
  * yaml-cpp: for masterlist/userlist parsing.
  * libespm: for plugin parsing.
  * libloadorder: for reading and writing load order.
  * libsvn: for accessing the Subversion repositories used.
  * cURL: for misc. networking.
  * wxWidgets: for the interface.
  * Boost: for filesystem interaction, various helpful functions.

As a reflection of this, LOOT's API will provide functions only for
accessing LOOT-specific functionality and data, eg. masterlist / userlist reading,
masterlist download and user edits submission.

The support for arbitrary data sources will be implemented by having the source
LOOT uses specified in a settings file, which will be editable via the GUI.

Because auto-sorting requires LOOT to know what is inside the plugins it sorts,
it must scan the plugins, and determine which of its records are new and which
are edited (new records aren't used for determining load order).

Optimisations can be made to skip load order
calculation. For example, if the only changes from the last load order set by
LOOT is that a plugin or plugins have been removed, then the last load order
may be used. It might also be possible to only perform partial calculation
when plugins are added, though this is not certain. It might not also be worth
the effort, since preliminary testing shows that scanning is considerably
faster than first anticipated.

Note: For clarity, the he list of metadata that is maintained by the
LOOT team will be referred to as the "masterlist", and the list of metadata that
is individual to each user will be referred to as the "userlist".


LOOT Masterlist & Userlist
==========================

The purpose of the masterlist is to store the following data for plugins:

  * Implicit and explicit requirements in load order.
  * Incompatibilities, for catching unresolveable conflicts.
  * Messages, for displaying information about the plugins.
  * The intended priority of the plugin relative to others that make the same
    changes.
  * Possibly also Bash Tags to be applied.

It is also useful to store some data not associated with plugins, such as:

  * Global messages.
  * Message objects, for reference instead of rewriting the same message
    multiple times.
  * File objects, for reference instead of rewriting the same condition
    argument multiple times.

All messages and files should also be optionally conditional on an arbitrary
number of conditions.

The purpose of the userlist is to store modifications to masterlist plugin data,
and to also store user-specified positions of plugins. The userlist must also
support the disabling of plugin entries within it, so that users can turn off
their changes without deleting them.

As the masterlist and userlist are very similar, it makes sense for them to use
the same format. The userlist could then simply support two data fields that are
ignored by the masterlist parser. I think that YAML is a suitable format for
these files as it is simple, human-readable, yet quite powerful.

The drag 'n' drop plugin positioning will likely require userlist rules
to support positioning of plugins precisely relative to other plugins, but it
may be possible to achieve the positioning using only the priority setting. If
possible, that is preferred.

When the masterlist/userlist is loaded, it is scanned for entries for each of
the installed plugins. If more than one match is found, they should be merged.

Further details can be found in the 'docs/BOSS Metadata File Syntax.html' file.


Networking
==========

LOOT has two target networking functionalities:

    * Masterlist updating.
    * User feedback submission.

Neither of these functionalities are critical to usage of LOOT.

The masterlist repository will use Subversion, as this
allows users to most easily download only the file they require, and only the
diffs of that file.

The masterlists would be stored using a folder structure that mirrors LOOT's
install structure, for example:

repo/
    Oblivion/
            masterlist.yaml

"repo" does not have to be the repository root, but LOOT's settings should
use the URL pointing to that location. The repo will be required to use the same
game folder names as LOOT's install structure.

The masterlist update mechanism will feature a validator such that if the
masterlist downloaded cannot be parsed, it will not replace the current
masterlist (if exists). The log will display notification of validation failure
with instructions to inform the maintainers of this issue. This is a fairly
major improvement over BOSS currently, which becomes unusable when a masterlist
update is occassionally broken.

The final bit of networking to be considered is the feedback mechanism. It's not
an initial development target, as initially I think it would be better for all
communication between users and the team to be two-way, which is easier
accomplished through our forum threads. It's probably best to leave design of
this until we see what sort of feedback users are giving.

A program update checker is notably absent, as a fully automated updater is
not worth the trouble of implementing well, and notification of an available
update is easily performed through a global masterlist message and so does not
require an additional transport mechanism.


Install Structure
=================

LOOT will be a self-contained installation that can be dropped anywhere. It will
have an installer option that also installs some Start menu shortcuts and a
Registry entry, but these will not be required for LOOT to function.

The directory structure will be as follows:

LOOT/
        Morrowind/
                .svn/
                        ...
                Cache/
                        .svn/
                                ...
                        m/
                                o/
                                        morrowind.esm.lmdb
                                        ...
                masterlist.yaml
                userlist.yaml
                lastrun.yaml
                loadorder.old
        Oblivion/
                .svn/
                        ...
                Cache/
                        .svn/
                                ...
                        o/
                                b/
                                        oblivion.esm.lmdb
                                        ...
                masterlist.yaml
                userlist.yaml
                lastrun.yaml
                loadorder.old
        Skyrim/
                .svn/
                        ...
                Cache/
                        .svn/
                                ...
                        s/
                                k/
                                        skyrim.esm.lmdb
                                        ...
                masterlist.yaml
                userlist.yaml
                lastrun.yaml
                loadorder.old
        Fallout3/
                .svn/
                        ...
                Cache/
                        .svn/
                                ...
                        f/
                                a/
                                        fallout3.esm.lmdb
                                        ...
                masterlist.yaml
                userlist.yaml
                lastrun.yaml
                loadorder.old
        FalloutNewVegas/
                .svn/
                        ...
                Cache/
                        .svn/
                                ...
                        f/
                                a/
                                        falloutNV.esm.lmdb
                                        ...
                masterlist.yaml
                userlist.yaml
                lastrun.yaml
                loadorder.old
        LOOT.exe
        LOOT.ini

lastrun.yaml stores the last load order set by LOOT, with the messages
displayed at that time, and uses the same format as the masterlist and userlist.

loadorder.old stores the load order before LOOT was last run.

The game caches are for storing database files so that they can be used when
there is no Internet connection. Each cache acts as separate working copy of
the database repository, holding the files it needs. They are separate to
help prevent name clashes between games. Each game folder also acts as a working
copy of the folder which stores the masterlist for that game on the repository.


Configuration
=============

LOOT will store its settings in a LOOT.ini file in its install directory. This
file should contain the following settings:

bEnableNetworking               Boolean
bUseOnlineCache                 Boolean         Cache = Database
bGetMetadataUpdates             Boolean         Metadata = Masterlist
bPromptMetadataSubmit   Boolean
bAlwaysSubmitMetadata   Boolean         Only has effect if the above is false.

sOnlineCacheURL                 String          URL to the base of the database repository.
sMetadataURL                    String
sVersionCheckerURL              String          URL to the file holding version info.
sFeedbackURL                    String          URL to the issue tracker used for feedback.

sGame                                   String          Same as in BOSS.
sLastGame                               String          Same as in BOSS.
iDebugVerbosity                 Integer         Debug output is logged if > 0.
bDoTrialRun                             Boolean         Same as in BOSS.
sLanguage                               String          Same as in BOSS.


Cross-Platform Support
======================

I develop on Linux, cross-compiling for Windows. LOOT will use the CMake build
system generator so that it can be compiled on multiple platforms, though some
functionality will require Windows-specific things, such as Registry queries.


Backwards Compatibility
=======================

No backwards compatibility with previous versions of BOSS is planned: there are
simply too many changes. To ease the transition though, it may be beneficial for
there to be converters for the userlist and masterlist.

Such converters would be limited in scope, however, due to the differences in
capabilities: only userlist rules which sort plugins after others and perform no
message changes have direct conversions. The masterlist may be adapted by having
rules created for those plugins with messages attached, but the content of those
messages would have to be adjusted manually, and all specific positioning
information would be lost too.


Misc
====

Here is the full list of BOSS members at the end of 2012. Any of these who lose
their membership status should still be credited in the BOSS readme:

Random007, Arthmoor, WrinklyNinja, PacificMorrowind, aellis, Vacuity, Gabba,
ZiggyX200, RiddlingLynx, AliTheLord, Tokc.D.K., Valda, Space Oden69, Televator,
Leandro Conde, Psymon, Loucifer, Torrello, Malonn, Skyline, Sharlikran, Red Eye,
iyumichan, Peste, Calen Ellefson, SilentSpike, Arkangel, zyp, v111, Chevenga,
rowynyew
