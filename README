BOSSv3
======

Introduction
============

See BOSS: http://code.google.com/p/better-oblivion-sorting-software/

BOSSv3 is being developed on a separate repository from the rest of BOSS's code as it is essentially a new program, and is being designed to address the shortcomings that are inherent in how BOSS approaches load order optimisation.

So what's wrong with BOSS? Why do I feel the need to go back to the drawing board?

Well, modding for Bethesda's games has proved to be incredibly popular, with over 25,000 mods each available for Oblivion and Skyrim.

For BOSS to be as useful as possible, it needs to be able to sort as many mods as possible. For Skyrim, the backlog of mods that need adding to its masterlist is at 5,800+ and growing. Recruiting extra team members isn't a real solution, as I've already done that and frankly copy/pasting filenames into a massive text file is not a whole load of fun and any analysis takes a while to do properly.

The other obvious solution is to cut down on the number of mods that need to be added to the masterlist - instead of having every single mod listed, BOSS could be made to sort the 'simple' mods on its own, and then we could add to the masterlist only those that proved too tricky for it to position itself.

While that's being done, I might as well also make some improvements to other areas of BOSS.


Design Notes
============

BOSS should be able to identify a reasonably correct load order for a group of arbitrary plugins based on their contents. However, there are always some plugins that must be positioned in certain ways relative to other plugins due to author intent that cannot be determined from their contents. There is also generally an element of user preference in setting a load order. BOSS should also be able to provide mechanisms for dealing with such plugins and preferences in addition to its basic 'reasonably correct' sorting.

BOSSv3's masterlist will therefore be used to provide unordered data sets for plugins that require them, and the userlist used to allow users to override the automatic sorting and to provide additional metadata themselves. They will be quite different to the current masterlist and userlist, and will use a new language/format.

If the 'impact' of a plugin is defined as the number of its edits that get applied to a person's game divided by the total number of edits it makes, then an 'optimum' load order is one that maximises the average impact of its constituent plugins whilst satisfying all explicit dependencies. A 'correct' load order is not necessarily an optimum load order though, as some plugins may be made with the intent that they are overridden by other plugins.

For flexibility, the 'masterlist' data file that gets updated by the BOSS Team should have its online location as a configurable option within BOSS, so that should its location change for whatever reason, users would be able to redirect their copy of BOSS to look in the new location. It might be a good idea to download it via a diff, or allow compression, somehow as the Skyrim masterlist is 1.7 MB. 

BOSSv3 will also have an API for accessing BOSS data and functionality. The more general functionality found in v2's API has already been forked to libloadorder, which v3 shall make use of.

Unlike v2, v3 will not have a built-in updater/update checker. It's just too much of a headache to code and manage for the payoff it gives, especially since notifications can be sent to users via the masterlist.

When run, BOSS shall output its results to a "log.yaml" file, which shall then be interpreted by the UI to display the BOSS Log.

BOSSv3 won't have a command line interface. Command line options may be added to the GUI if requested. Users need to be made aware that what BOSS sets isn't the absolutely perfect load order, and is open to tweaking, which is being lost on some people currently, in part due to the 'one click' nature of BOSS.


Roadmap
=======

- Write new masterlist, userlist, settings file parsers. DONE
- Implement per-game handling. DONE
- Write API. DONE
- Develop sorting algorithm.
- Tie together automatic 'simple' sorting with masterlist, userlist data parsing and usage. DONE
- Write masterlist updating code.
- Develop graphical user interface.
- Error handling.
- Initialisation and finishing routines (read settings file, write log file, etc.).


Sorting Algorithm
=================

Given two plugins A and B, their load order only matters if they both change a third plugin's records or if one changes the other's records. In such a case, the plugins can be said to 'overlap'.

The hard rules of load ordering are:
  1. Master files always load before non-master files.
  2. A plugin must load after all its masters.

Beyond that, the following can be used to maximise the impact of two plugins:
  1. Compute the overlap between A and B. Divide the overlap size by the number of records in each plugin, and the plugin with the larger ratio should load later, as more of its overall changes would be lost if it loaded first than if the other plugin does.

There are issues related to author intent: for example, the Unofficial Patches contain a large number of mostly edited records, as does a Bashed Patch, but the former is intended to load early and be overridden by other plugins while the latter is designed to load late. It's not clear how such situations can be resolved.

One possibility is to have a 'priority' metadata field, which has a default value, a value signifying the plugin should load late, and a value signifying the plugin should load early. If left at the default value, the plugin would be sorted by the algorithm normally, but if set to the early value, the plugin would be moved as far up the load order as the hard rules allow, and if set to the late value, would be moved as far down the load order as the hard rules allow. If multiple plugins are present that load early or late, then within that set of plugins the algorithm could be applied normally.

It's not a great solution though, being far too imprecise for my liking, but then the loading intention is also vague. 

Optimisations may also be made, such as not performing any new sorting if the only differences since previous sorting are the removal of plugins, or if the plugins added only add new records they can just be placed at the end.


Data Files Format
=================

BOSSv3's settings file, masterlist, userlist and previous run logs will all be written in YAML. This allows me to take advantage of existing parsing libraries and the format's flexibility. It's also not that much more verbose than v2's masterlist format, once data structure changes are taken into account.

A custom parser is required for the evaluation of conditions though. The syntax has been made more human readable and compound conditions now evaluate according to standard logic.

The masterlist and userlist will use the same parser, and simply combined by merging or replacing plugin metadata where depending on the type of metadata.

Further details can be found in the 'docs/BOSS Metadata File Syntax.html' file. An example settings file can be found at 'examples/settings.yaml'.


Install Structure
=================

LOOT will be a self-contained installation that can be dropped anywhere. It will have an installer option that also installs some Start menu shortcuts and a Registry entry, but these will not be required for LOOT to function.

The directory structure will be identical to that which BOSS currently has, with the exception that the text and ini files will be replaced by YAML files.


Misc
====

Here is the full list of BOSS members at the end of 2012. Any of these who lose
their membership status should still be credited in the BOSS readme:

Random007, Arthmoor, WrinklyNinja, PacificMorrowind, aellis, Vacuity, Gabba,
ZiggyX200, RiddlingLynx, AliTheLord, Tokc.D.K., Valda, Space Oden69, Televator,
Leandro Conde, Psymon, Loucifer, Torrello, Malonn, Skyline, Sharlikran, Red Eye,
iyumichan, Peste, Calen Ellefson, SilentSpike, Arkangel, zyp, v111, Chevenga,
rowynyew
  

Backwards Compatibility
=======================

BOSSv3 will not be backwards compatible with previous versions of BOSS: that is, it will not be able to use masterlists, userlists, translation files and ini files from previous versions of BOSS.

It may be possible to perform limited conversion from v2 masterlists and userlists to their v3 equivalents, but as their capabilities have substantially changed, much of them may be untransferrable or at least not automatically transferable.

A userlist converter would be most useful, since that would make most people's switch between v2 and v3 easier. The masterlists will probably have to be manually scanned for useful information.

Userlist Conversion
-------------------

Differences between BOSSv2 and v3:

  - In v2, plugins can be sorted before or after other plugins, but v3 only supports sorting after other plugins.
  - In v2, it is possible to replace or append to masterlist messages. In v3, the user can only append messages.
  - In v2, it is possible to sort groups or relative to groups, but groups do not exist in v3.
  - In v2, the order of rules affects their execution. In v3 the order of rules doesn't matter.
  - In v2, requirements and incompatibilities are added in messages, but in v3 they are added in a separate data structure.

Conversion for syntax is just a matter of reading in using the old parser and writing out using the new generator. If any of the following are detected in a rule, conversion should be aborted and error messages detailing why displayed, asking the user to make the relevant changes before running the converter again.

  - If the rule object is a group.
  - If the sort keyword is 'BEFORE', 'TOP' or 'BOTTOM'.
  - If the sort object is a group.
  - If the message keyword is 'REPLACE'.
  - If the message object's keyword is 'REQ' or 'INC'.

If any of the following are detected, then BOSS should display a warning that the result may differ from the original:

  - If a message object's keyword is 'TAG'.
  - If more than one rule references the same sort object or the same plugin appears as a sort object in one rule and a rule object in another.

Additionally, a warning should be displayed that all comments will be ignored.
